name: AI Review Smart Cleanup

on:
  pull_request:
    # PRì´ ìƒˆë¡œ ì—´ë¦¬ê±°ë‚˜, ì»¤ë°‹ì´ ì¶”ê°€ë˜ê±°ë‚˜, ë‹«í˜”ë‹¤ ë‹¤ì‹œ ì—´ë¦´ ë•Œ ì‹¤í–‰
    types: [opened, synchronize, reopened]

# [ê¶Œê³  3] ë™ì¼ PRì˜ ì´ì „ ì‹¤í–‰ì„ ì·¨ì†Œí•´ ì¤‘ë³µ ì‹¤í–‰ ë° ë¶ˆí•„ìš”í•œ API í˜¸ì¶œ ë°©ì§€
concurrency:
  group: ai-review-cleanup-pr-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:
  smart-cleanup:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: read

    steps:
      - name: Cleanup Stale AI Comments
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            /**
             * ë´‡ ê³„ì • íŒë³„: GitHub ë´‡ì€ ë¡œê·¸ì¸ëª…ì´ '[bot]'ìœ¼ë¡œ ëë‚¨
             * ì˜ˆ) copilot[bot], github-actions[bot], coderabbitai[bot]
             * loginì´ null/undefinedì¸ ê²½ìš°(ì‚­ì œëœ ì‚¬ìš©ì ë“±)ë„ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬
             */
            function isBot(login) {
              return login != null && login.endsWith('[bot]');
            }

            // [ê¶Œê³  1] cursor ê¸°ë°˜ í˜ì´ì§€ë„¤ì´ì…˜ìœ¼ë¡œ 100ê°œ ì´ìƒì˜ ìŠ¤ë ˆë“œ/ì½”ë©˜íŠ¸ ëˆ„ë½ ë°©ì§€
            const threadQuery = `
              query($owner: String!, $repo: String!, $prNumber: Int!, $threadCursor: String) {
                repository(owner: $owner, name: $repo) {
                  pullRequest(number: $prNumber) {
                    reviewThreads(first: 100, after: $threadCursor) {
                      pageInfo { hasNextPage endCursor }
                      nodes {
                        id
                        isResolved
                        comments(first: 50) {
                          # ì²« í˜ì´ì§€ë§Œ ê°€ì ¸ì˜¤ê³ , 50ê°œ ì´ˆê³¼ ì‹œ commentQueryë¡œ ì¶”ê°€ í˜ì´ì§€ ì²˜ë¦¬
                          pageInfo { hasNextPage endCursor }
                          nodes {
                            id
                            # databaseId: deprecatedì´ì§€ë§Œ REST API deleteReviewComment()ê°€
                            # ìˆ«ì IDë¥¼ ìš”êµ¬í•˜ë¯€ë¡œ ì‚¬ìš© ë¶ˆê°€í”¼
                            databaseId
                            author { login }
                          }
                        }
                      }
                    }
                  }
                }
              }
            `;

            const commentQuery = `
              query($owner: String!, $repo: String!, $prNumber: Int!, $threadId: ID!, $commentCursor: String) {
                node(id: $threadId) {
                  ... on PullRequestReviewThread {
                    comments(first: 50, after: $commentCursor) {
                      pageInfo { hasNextPage endCursor }
                      nodes {
                        id
                        databaseId
                        author { login }
                      }
                    }
                  }
                }
              }
            `;

            // ìŠ¤ë ˆë“œ ì „ì²´ë¥¼ í˜ì´ì§€ë„¤ì´ì…˜ìœ¼ë¡œ ìˆ˜ì§‘
            const allThreads = [];
            let threadCursor = null;

            do {
              const result = await github.graphql(threadQuery, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                prNumber: context.payload.pull_request.number,
                threadCursor
              });
              const page = result.repository.pullRequest.reviewThreads;

              // ê° ìŠ¤ë ˆë“œì˜ ì½”ë©˜íŠ¸ë„ í˜ì´ì§€ë„¤ì´ì…˜ ì²˜ë¦¬
              for (const thread of page.nodes) {
                let comments = [...thread.comments.nodes];
                let commentPageInfo = thread.comments.pageInfo;

                while (commentPageInfo.hasNextPage) {
                  const commentResult = await github.graphql(commentQuery, {
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    prNumber: context.payload.pull_request.number,
                    threadId: thread.id,
                    commentCursor: commentPageInfo.endCursor
                  });
                  const commentPage = commentResult.node.comments;
                  comments = comments.concat(commentPage.nodes);
                  commentPageInfo = commentPage.pageInfo;
                }

                allThreads.push({ ...thread, allComments: comments });
              }

              threadCursor = page.pageInfo.hasNextPage ? page.pageInfo.endCursor : null;
            } while (threadCursor);

            console.log(`ì´ ${allThreads.length}ê°œì˜ ë¦¬ë·° ìŠ¤ë ˆë“œë¥¼ ë¶„ì„í•©ë‹ˆë‹¤.`);

            let deletedCount = 0;
            let failedCount = 0;

            for (const thread of allThreads) {
              const comments = thread.allComments;
              if (comments.length === 0) continue;

              // âœ… ë³´ì¡´ ê·œì¹™ 1: Resolved(í•´ê²°ë¨) ìŠ¤ë ˆë“œ â€” ìˆ˜ì • ì™„ë£Œëœ ìœ ì˜ë¯¸í•œ ê¸°ë¡
              if (thread.isResolved) continue;

              // âœ… ë³´ì¡´ ê·œì¹™ 2: ì‚¬ëŒì´ ë‹µê¸€ì„ ë‹¨ ìŠ¤ë ˆë“œ â€” ì§„í–‰ ì¤‘ì¸ í† ë¡ , ë§¥ë½ ìœ ì§€
              // authorê°€ nullì¸ ê²½ìš°(ì‚­ì œëœ ì‚¬ìš©ì)ëŠ” ë´‡ì´ ì•„ë‹Œ ê²ƒìœ¼ë¡œ ê°„ì£¼í•´ ë³´ì¡´
              const hasHumanReply = comments.some(c => !isBot(c.author?.login));
              if (hasHumanReply) continue;

              // ğŸ—‘ï¸ ì‚­ì œ ëŒ€ìƒ: ë´‡ì´ ì‹œì‘í–ˆê³ , ë¯¸í•´ê²°ì´ë©°, ì‚¬ëŒ ê°œì…ì´ ì—†ëŠ” ê³ ë¦½ëœ ìŠ¤ë ˆë“œ
              const firstAuthor = comments[0]?.author?.login;
              if (!firstAuthor || !isBot(firstAuthor)) continue;

              console.log(`ì‚­ì œ ëŒ€ìƒ ë°œê²¬: ë´‡ ë‹¨ë… ë¯¸í•´ê²° ìŠ¤ë ˆë“œ (ì½”ë©˜íŠ¸ ${comments.length}ê°œ, ì‘ì„±ì: ${firstAuthor})`);

              for (const comment of comments) {
                try {
                  await github.rest.pulls.deleteReviewComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    comment_id: comment.databaseId
                  });
                  console.log(`ì‚­ì œ ì™„ë£Œ: ì½”ë©˜íŠ¸ #${comment.databaseId}`);
                  deletedCount++;
                } catch (e) {
                  // [ê¶Œê³  2] ì—ëŸ¬ ìƒíƒœ ì½”ë“œë³„ ë¶„ê¸° ì²˜ë¦¬
                  const status = e.status ?? e.response?.status ?? null;

                  if (status === 404) {
                    // ì´ë¯¸ ì‚­ì œëœ ì½”ë©˜íŠ¸ â€” ì •ìƒ, ë¬´ì‹œ
                    console.log(`ì½”ë©˜íŠ¸ #${comment.databaseId}ëŠ” ì´ë¯¸ ì‚­ì œë¨, ê±´ë„ˆëœë‹ˆë‹¤.`);
                    continue;
                  }

                  if (status === 403 || status === 401) {
                    // ê¶Œí•œ ë¶€ì¡± â€” Minimize(ìˆ¨ê¹€)ìœ¼ë¡œ í´ë°±
                    // ì°¸ê³ : minimizeë„ ë™ì¼ ê¶Œí•œ ë¬¸ì œë¡œ ì‹¤íŒ¨í•  ìˆ˜ ìˆìœ¼ë©°, ì‹¤íŒ¨ ì‹œ ë¡œê·¸ë§Œ ë‚¨ê¹€
                    console.log(`ì‚­ì œ ê¶Œí•œ ì—†ìŒ (HTTP ${status}), Minimize ì²˜ë¦¬ ì‹œë„ ì¤‘...`);
                    try {
                      await github.graphql(`
                        mutation($subjectId: ID!) {
                          minimizeComment(input: { subjectId: $subjectId, classifier: OUTDATED }) {
                            minimizedComment { isMinimized }
                          }
                        }
                      `, { subjectId: comment.id });
                      console.log(`Minimize ì²˜ë¦¬ ì™„ë£Œ: ì½”ë©˜íŠ¸ #${comment.databaseId}`);
                    } catch (me) {
                      console.log(`Minimizeë„ ì‹¤íŒ¨: ${me.message}`);
                      failedCount++;
                    }
                  } else {
                    // ì¼ì‹œì  ì˜¤ë¥˜(5xx ë“±) â€” ì¬ì‹œë„ ì—†ì´ ë¡œê·¸ë§Œ ë‚¨ê¹€
                    console.log(`ì¼ì‹œì  ì˜¤ë¥˜ (HTTP ${status ?? 'unknown'}), ê±´ë„ˆëœë‹ˆë‹¤: ${e.message}`);
                    failedCount++;
                  }
                }
              }
            }

            // Job Summaryì— ì‹¤í–‰ ê²°ê³¼ ì¶œë ¥
            await core.summary
              .addHeading('AI ë¦¬ë·° í´ë¦°ì—… ê²°ê³¼')
              .addTable([
                [{ data: 'í•­ëª©', header: true }, { data: 'ìˆ˜ëŸ‰', header: true }],
                ['ë¶„ì„í•œ ìŠ¤ë ˆë“œ', String(allThreads.length)],
                ['ì‚­ì œ ì„±ê³µ', String(deletedCount)],
                ['ì‹¤íŒ¨/ê±´ë„ˆëœ€', String(failedCount)]
              ])
              .write();
